# -*- coding: utf-8 -*-
"""Finite_diference_method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ds_bEJPail88fdoYxd8CxaQ8HIi4-lMY
"""

import math
import numpy as np
from numpy import linalg as LA
import matplotlib.pyplot  as  plt
Dx = 1
Dy = 1
M = 20
h = (1.0 - 0)/(M)
A = np.zeros(((M+1)*(M+1), (M+1)*(M+1)) , 'double' )
f = np.zeros((M+1)*(M+1), 'double')
pi = math.pi
def g_n(x):
  return 0
def g_l(y):
  return -Dx*np.cos(pi*y)
def g_v(x):
  return 0
def g_p(y):
  return np.exp(-1)*np.cos(pi*y)
def F(x, y):
  return (Dy*pi*pi - Dx)*np.exp(-x)*np.cos(pi*y)
for k in range(0, (M+1)*(M+1)):
    xi = ( k % (M + 1) )*h
    yj = ( k // (M+1) )*h
    if (k == 0): #Левый нижний угол
      A[k][k] = -(Dx + Dy)
      A[k][k+M+1] = Dy
      A[k][k + 1] = Dx
      f[k] = h*g_l(0) + h*g_n(0) - 0.5*h*h*F(0, 0)
    elif (k == M): #Правый нижний угол
      A[k][k] = 1
      f[k] = np.exp(-1)
    elif (k < M): #Нижняя граница
      A[k][k] = -Dy-Dx
      A[k][k - 1] = 0.5*Dx
      A[k][k + 1] = 0.5*Dx
      A[k][k+M+1] = Dy
      f[k] = h*g_n(xi) - 0.5*h*h*F(xi, 0)
    elif (k == (M+1)*(M+1) - 1): #Правый верхний угол
      A[k][k] = 1
      f[k] = -np.exp(-1)
    elif (k == (M+1)*M): #Левый верхний угол коррект
      A[k][k] = -(Dx + Dy)
      A[k][k-M-1] = Dy
      A[k][k + 1] = Dx
      f[k] = h*(g_l(1) + g_v(0)) - 0.5*h*h*F(0, 1)
    elif (k > M*(M+1)): #Верхняя граница коррект
      A[k][k] = -Dx-Dy
      A[k][k - M - 1] = Dy
      A[k][k - 1] = 0.5*Dx
      A[k][k + 1] = 0.5 *Dx
      f[k] = h*g_v(xi) - 0.5*h*h*F(xi, 1)
    elif (k % (M+1) == 0): #Левая граница коррект
      A[k][k] =-(Dx+Dy)
      A[k][k+1] = Dx
      A[k][k+1+M] = 0.5*Dy
      A[k][k-1-M] = 0.5*Dy
      f[k] = h*g_l(yj) - 0.5*h*h*F(0, yj)
    elif ((k+1)%(M+1) == 0):
      A[k][k] = 1
      f[k] = g_p(yj)
    else: #Внутренние точки
      A[k][k] = 2*(Dx + Dy)
      A[k][k-1] = -Dx
      A[k][k+1] = -Dx
      A[k][k+M+1] = -Dy
      A[k][k-M-1] = -Dy
      f[k] = F(xi, yj)*h*h

# print(A)
# print(f)
C1 = np.linalg.solve(A, f)
# print(C1)

C_exact = np.zeros((M+1)*(M+1), 'double')
for k in range(0, (M+1)*(M+1)):
    xi = (k % (M + 1)) * h
    yj = (k // (M + 1)) * h
    C_exact[k] = np.exp(-xi)*np.cos(pi*yj)
# print(C_exact)
print(np.linalg.norm(C1 - C_exact, np.inf) )

x = np.zeros((M+1),'float')
for i in range(0, (M+1)):
  x[i] = i*h
y = np.zeros((M+1),'float')
for j in range(0, (M+1)):
  y[j] = j*h
C1= np.reshape(C1, (M+1, M+1))
x_1,y_1 = np.meshgrid(x,y)
my_map = plt.get_cmap('rainbow')
plt.contourf(x_1,y_1,C1,cmap=my_map)
plt.colorbar()
plt.show()
X=np.linspace(0, 1, M+1)
Y=np.linspace(0, 1, M+1)
X1,Y1=np.meshgrid(X, Y)
fig = plt.figure()
ax = plt.axes(projection = "3d")
ax.plot_surface(X1,Y1,C1, cmap= "viridis")
ax.set_xlabel("x")
ax.set_ylabel("y")
plt.show()
C_exact= np.reshape(C_exact, (M+1, M+1))
X=np.linspace(0, 1, M+1)
Y=np.linspace(0, 1, M+1)
X1,Y1=np.meshgrid(X, Y)
fig = plt.figure()
ax = plt.axes(projection = "3d")
ax.plot_surface(X1,Y1,C_exact, cmap= "viridis")
ax.set_xlabel("x")
ax.set_ylabel("y")